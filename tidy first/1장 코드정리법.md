# 1장 코드정리법

### 1  보호구문

주로 낮은 년차의 직원들이 많이 작성하던데, 

```java
if (innerCollection == null) {
	innerCollection = new ArrayList<>();
	if (needDummy) {
		innerCollection.add("dummy1");
		innerCollection.add("dummy2");
	}
}
return innerCollection;
```

```java
if (innerCollection != null) {
	return innerCollection;
}

innerCollection = new ArrayList<>();
if (needDummy) {
	innerCollection.add("dummy1");
	innerCollection.add("dummy2");
}
return innerCollection;
```

예를 들려다보니 needDummy 에 대해 약간 맞지 않는 부분이 있을수 있지만 넘어가자.

생각의 흐름대로 작성하다보면 위와 같은 코드를 작성하기 쉽지만, 여러 중첩문이 섞이면 정리가 어려워지기 때문에 로직 작성 이전에 보호코드를 작성해라. 근데 이것도 많이 쓰면 헷갈림.

### 2 안 쓰는 코드

안쓰는 코드는 지워라. 어차피 버전관리 하고있으니 필요하다면 거기서 롤백해서 써라.

요즘은 ide에서도 참조되지 않는 메소드는 경고를 보여주니 판단이 더 쉬울듯.

그런데 메소드안에서 타지 않는 분기를 발견했다고 해서 막 지우면 후회할수있으니 적당히 조금씩 지워라.

가끔 근 시일내 사용할거같아서 주석으로만 만들어두는 블록을 만드는데, 습관이라..

### 3 대칭으로 맞추기

코드를 작성할때, 비슷한 스타일의 패턴으로 작성하면 같이 일하는 사람들이 읽기 쉽다.

코드 일관성에 대한 이야기인데, 예를들어 

```java
return "hello! World";
//
String greetings = "hello! world";
return greetings;
```

두가지 타입이 있을때에, 특별한 이유가 없다면 한가지만 사용해라. (문자열을 하드코드한 부분은 무시하고)

### 4 새로운 인터페이스로 기존 루틴 부르기

약간 내용이 혼란스러운데, 일종의 어댑터 패턴을 사용하라는 이야기로 들림.

기존 인터페이스가 복잡하면 내가 필요한 부분만 새로 인터페이스를 작성하되, 

새로 작성한 인터페이스에서는 기존 인터페이스를 호출하고,

충분히 새로운 인터페이스를 성숙시켰다면 기존 인터페이스를 제거하고 새로운 인터페이스에서 루틴을 구현해라.

### 5 읽는 순서

소스는 읽기 쉬운 순서로 작성해라.

소스코드도 문서(산출물)의 일종으로 볼수있다. 그러므로 시간적 결합이 없는 라인들은 읽기 쉬운순서대로 작성해라.

너무 당연한 이야긴데,

시간적 결합이 있는 경우

객체 내부 필드가 변하기 때문에 순서에 따라 결과가 달라지는경우 (결국 시간적 결합) 

위와 같은 경우 주의해라.

### 6 응집도를 높이는 배치

기본적으로 소스는 응집도가 높고 결합도가 낮아야 한다.

자바같은 경우 패키지를 통해 관련된 클래스를 가까이 배치해 응집도를 높일수 있는데, 

모든 언어가 그런건 아니고..

그런데 여기저기에 결합이 있는 경우는 어떻게 하죠?

그건 클래스가 너무 많은 일을 하고 있는거니까 리팩토링해라 < 라는 뜻이 담겨있는거같다.

하지만 너무 이리저리 옮긴다면 팀원이 혼란스러울수 있다.

### 7 선언과 초기화를 함께 옮기기

변수 선언과 초기화가 동떨어진 위치가 될수도 있다.

근데 굳이 그럴 필요없다면 가까이에 두어 변수의 존재 의의를 강화해라.

자바의 경우 강타입언어이기 때문에 이름만 잘 짓는다면 별 문제 없겠지만

자바 var나 코틀린같은경우(혹은 여러 인터프리터들) 선언과 동시에 초기화 혹은 가까운곳에서 초기화를 통해 변수가 무엇을 뜻하는지 확실히 전달할수 있다.

근데 이마저도 메서드를 짧게 유지하면 필요없을듯?

### 8 설명하는 변수

책에서는 아래와 같이 설명하는데

```java
return new Point(someShapes[0].leftest.pos.x, someShapes[0].rightest.pos.y);
//
leftest_y = someShapes[0].leftest.pos.x;
rightest_x = someShapes[0].rightest.pos.y;
return new Point(leftest_y, rightest_x);
```

만약 첫줄이 너무 길거나, 많은 양의 파라미터가 들어가야한다면 이 줄이 무엇을 하는 줄인지 이해하기 어려울때가 있음. 

나의 경우 주로 테스트코드를 저런식으로 작성하는데, 무엇을 return하는것인지가 중요하지 무슨 값을 어떻게 가져오는지가 중요한것이 아니기 때문에 아래처럼 작성하라는 이야기같다.

### 9 설명하는 상수

```java
if(404 == resCode) 
//
final int PAGE_NOT_FOUND = 404;
...
if(PAGE_NOT_FOUND == resCode)
```

귀찮다고 위와같이 사용할때가 많은데 물론 위와같이 이미 세계적으로 강력하게 정의된 404 not found가 바뀔리 없지만, 다른 인터페이스에서는 리턴코드 변경따위가 잦고, 있을수 없는 일이라고 아무도 장담할수 없기 때문에 상수는 미리 정의해두고 사용해라.

값에 할당된 의미를 이해하는데도 도움이 됨.

그런데 같은 값이라고 해서 여기서 사용해야할 상수가 아닌데도 가져다 쓰지마라. 나중에 변경되면 버그를 일으킬수 있고, 보는 사람도 혼란스러움.

### 10 명시적인 매개변수

전달하는 파라미터는 명시적이여야 한다. 

메소드간 전달하는 파라미터(메시지)가 필요하다면 dto를 생성해서 사용하지만, 그닥 크게 중요한것도 아니고 힘빼기 싫을때는(특히 인터프리터언어) 맵이나 튜플따위로 전달하는 일도 많다.

```java
private void printThis(List<String> param) {
	logger.debug("{} said : {}", param.get(0), param.get(1));
}
// 
private void printThis(String user, String input) {
	logger.debug("{} said : {}", user, input);
}
```

중요도가 낮고, 범용성이 필요할때는 위와같이 작성할때도 있겠지만(지금 예제 메소드의 중요성은 뒤로하고) 아래와 같이 작성하는것이 목적을 알기 쉽다. 테스트도 간단할거같고.

### 11 비슷한 코드끼리

코드를 작성할때 연관이 있는 라인끼리는 붙여서, 아닌 라인은 한칸띄고.

당장 리팩토링을 할순 없는 상황에서도 나중에 리팩토링을 해야할때 리팩토링 단서를 남길수 있다.

### 12 도우미 추출

코드 작성시 재사용의 유혹을 느끼는 라인은 추출하고, 목적에 맞는 이름을 붙이자.

다만 시간적 결합이 있는 코드가 발생할 경우에는 그 구간만 별도로 분리하여 시간적 결합을 고정시킬수 있도록 하자.

```python
username = input()
template = "hello! "
msg = template + username
print(msg)
## 사정상 username을 먼저 받기전에는 msg를 만들수 없다고 가정하자
def build_msg(template): ## 시간적 결합을 고정하기 위한 함수
	username = input()
	msg = template + username
	return msg

msg = build_msg("hello! ")
print(msg)
```

### 13 하나의 더미

이해가 힘들때는 코드를 모아서 정리하라.

이건 되도록이면 메소드 스코프를 줄이라는 조언과는 반대 되는 이야기가 된다.

우리는 기억해야하는게 많으면 어렵기 때문에 메소드라인수를 줄이고, 잘게 쪼개어 결합하여 재사용성을 늘리라고 배우지만 켄트 벡은 ‘이해하기 힘들다면’ 일단 모으고 다시 추출하는 방법으로 리팩토링 하라고 함.

### 14 설명하는 주석

코드에 명확하게 표시되지 않는 숨은 내용은 주석으로 관리하라.

예를들어, 언어단위에서 빌트인 메소드로 제공하는 기능을 작성해둔 메소드를 발견하였는데,

우리는 바퀴를 재발명 하지말라 라는 말을 머릿속에 가지고 있음.

실은 빌트인 메소드가 가진 취약점이나 비효율성때문에 재작성한 메소드라면 다른 사람들은 소스코드를 전부 읽어보기 전까지는 이 메소드의 필요성을 느끼지 못할수도 있다.

이런 특수한 상황때문에 주석을 남기라는 이야기.

### 15 불필요한 주석 지우기

14와 반대로 그냥 소스코드에서 이해할수 있는 내용은 굳이 주석으로 작성하지마라.

소스코드도 산출물이기 때문에 쓸데 없는 주석은 남기지말자.

주석도 유지보수의 대상이다. 제때 삭제되지 않는 주석은 혼란을 일으킴.