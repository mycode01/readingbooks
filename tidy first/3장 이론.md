# 3장 이론

1장 2장에서 나온 내용은 3장의 빌드업이었고, 

소프트웨어 설계(운영이 포함), 설계를 이어나가기 위한 두가지 방법,

그렇다면 언제 정리를 해야하나?를 이야기하기 위해 또 빙 돌아가는 이야기를 함.

핵심은 ‘그 선택은 너의 직관에 달렸다’ 라서 좀 깨름직함.

### 22 요소들을 유익하게 관계 맺는 일

소프트웨어 설계란 무엇인가? 에 대한 대답을 함.

뜬소리 다 치우고 소프트웨어 설계는 

1. 문장 > 함수 > 객체 > 시스템
2. 호출, 발행, 대기, 참조 등의 interaction, 상호작용

1번과 2번의 혼합이라고 표현함. 하지만 우리는 그냥 섞어서는 안되고 효율적으로.

그렇지 않으면 그냥 트랜잭션 스크립트랑 다를바가 없으니까.

여기서 최대한 이득을 볼수있게 하는것이 우리가 좋은 설계를 하는것이라고 함.

여기서 설계는 시스템 초반의 설계뿐만 아니라 유지보수도 포함한다.

### 23 구조와 동작

여기도 쓸데없이 말이 긴데, 

구조와 동작은 다르다. 두가지 변경의 차이는 가역성에 있다.

되돌릴수 있느냐 없느냐의 차이라고 함.

동작이 변경되면 큰 손해를 끼칠수도 있지만, 구조가 변경된다고 해서 큰 손해를 끼칠수 있을까?

여기서 말하는건 동작의 변경과 구조의 변경을 명확하게 하라 는 이야기인거 같음.

### 24 시간 가치와 선택 가능성

쓸데 없는 빌드업 

소프트웨어 설계도 두가지 선택이 있음.

일단 만들고, 나중에 정리한다.

나중의 변경을 대비해서 미리 정리한다.

### 25 오늘의 1달러가 내일의 1달러보다 크다

일단 만들고 나중에 정리하는 것에 대한 설명

미래의 불확실성에 대비하지말고 일단 동작하게 하는것을 설명함.

나중의 변경이 없거나 변경에 따른 잇점이 크지 않은지는 직관에 따를수 밖에 없다. 당연한 소리를..

### 26 옵션

나중의 변경을 위해 미리 대비하는 것에 대한 설명

나중을 대비하는것은 일종의 미덕이라고 생각한다. 당연히 해야하는 것이라고 여기기 쉽지만 그럼 어느정도로 대비해야하는가? 언제쯤 대비해야하는가? 이 두가지가 매우 어렵다.

켄트 벡은 가치에 대한 예측이 불확실할수록 바로 구현하는것보다 옵션이 가진 가치가 더 커진다. 라고 하는데, 일종의 도박이라고 느껴질정도로(당연히 그렇게 이해하라는건 아니겠지만) 불충분한 설명이다.

### 27 옵션과 현금흐름 비교

25와 26의 비교를 함.

3장의 핵심이라고 보이는 부분인데 다소 당연하다고 느껴지는 부분

미리 정리를 해야하나? 아니면 미리 정리하여 미래 불확실성에 대비하나?

비용(코드 정리) + 비용(코드 정리 후 동작 변경) < 비용(바로 동작 변경)

일때 미리 정리하라고 함. 당연히 바로 동작 변경했을때 이득을 볼수있다면(이득을 볼것임을 알수있다면) 동작 변경을 해야겠지. 그런데 얼마나 이득을볼 수 있을지 모르기 때문에 불확실성 이라고 표현하는거 아닌가?

여기서 잊기 쉬운부분에 대해서도 짚고 넘어가는데, 코드 정리에 따른 팀의 반발.

어떻게? 잘.

### 28 되돌릴 수 있는 구조 변경

23 구조와 동작의 차이는 가역성에 있다고 했음. 이를 어떻게 구분하나?

보통 큰 문제, 전파되는 문제(결합도) 는 되돌릴수 없는 변경일 가능성이 크다고 함.

이렇게 되기전에 코드 검토는 신중히 하라고 함. 코드에 드러나지 않은 문제가 있을수도 있으니까.

### 29 결합도

결합도가 왜 중요한지 설명함.

결합도는 소프트웨어 비용을 결정한다 라고 주장하는데, 소프트웨어 비용에 유지보수의 비용도 포함되니까 맞는 말이라고 생각한다. 

또, 결합도 분석은 소스코드를 보는거만으로는 알기 힘들수도 있다고 한다. 이를 알수 있는 방법은 과거 커밋 로그에서 쌍으로 변경되는 내용이 있는지를 보라고 함.

### 30 콘스탄틴의 등가성

프로그램은 유지보수 없이는 지속되기 힘들기 때문에(아주 간단하거나, 변경 가능성이 0에 수렴하는 것이 아니라면)

소프트웨어의 총 비용은 변경 비용과 비슷할 정도라고 주장한다.

약간 비약이 있는 주장이라고 생각하지만 내가 이런걸 연구하는 사람은 아니니까 그렇다 칩시다.

하지만 모든 변경이 비용이 비싸다는 이야기가 아니라, 그중 특출난 몇개의 변경이 나머지를 합친것보다 더 비싼 비용을 지불하게 된다라고 함.

자본주의 사회와 비슷하게 들림.

여기서 또 비약을 하여, 

소프트웨어 총 비용 ~= 큰 변경들

이런 큰 변경은 결국 결합도 문제에서 크게 벗어나지 않는다고 하며, 

소프트웨어 총 비용 ~= 전체변경 ~= 큰변경 ~= 결합도

소프트웨어 총 비용 ~= 결합도

라는 주장을 함.

비즈니스 사정상 말도 안되는 요구사항 변경을 제외하면 크게 틀린말도 아닌거같아 수긍함.

### 31 결합도 제거

그럼 그런 결합도를 왜 방치하는데? 당시에는 알기 힘드니까. 그리고 누구도 결합도에 대해 자유로울수 없다고 함. 

두가지 선택이 있음. 

1. 깐깐하게 결합도를 제거하며 비용을 지불하며 개발함 - 나중의 변경을 대비해서 미리 정리
2. 결합도가 생겨도 방치하고 빠르게 코드를 작성 - 일단 만들고 나중에 정리

25, 26에서 이야기했던것들. 다시한번 이것들은 선택이라고 강조함.

예제를 통해 결합도를 제거하는 방법(라고 주장)을 보여주지만, 

사실 결합도를 제거한것이 아니라 뒤로 미루어 두었을 뿐이다.

이런 방법을 통해서 결합도에게서 자유로울수 없는 이유를 설명함.

그럼 어떻게 하라고? 절충해야지. 결합도를 미리 제거하여 미리 비용(시간)을 지불하느냐,

결합도를 남겨두어 비용을 나중에 한꺼번에 지불하느냐.

적당한 선에서 하라고 함. 알아서.

### 32 응집도

응집도에 대한 이야길 굳이 할 필요는 없을거같은데.

암튼 결합도와 응집도는 떼어놓을수 없는 사이라 그런가 봄.

응집도를 개선하기 위한 두가지 방법, 

1. 하위 모듈을 만들어 자기들끼리 결합도를 가지게 함.
2. 결합되지 않은 요소를 적절한 곳에 각각 배치시킴.

급진적으로 하려고 하지말고, 깔끔하게 만들어라.

### 33 결론

그래서, 코드 정리가 먼저냐? 아니면 동작 변경이 먼저냐.

상황마다 다르다. 네가지 힌트를 보고 직관력을 키워라.

1. 비용 - 정리하면 비용(미래에 대한 비용도)이 줄어듬? 
2. 수익 - 유연하게 설계를 변경하면 나중에 이득을 볼수있음? (변경 가능성이 없는데 힘빼지마라)
3. 결합도 - 변경할때 같이 바뀌는 요소들이 줄어듬?
4. 응집도 - 변경에 따른 범위가 줄어듬?

코드 정리에 너무 집착하지마라. 모든것은 비용과 트레이드오프관계이다. 무지성으로 변경하면 다른 팀원이 반발할것이다.